<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Chatbot - BizPilot</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = { theme: { extend: { colors: { accent: '#D01B22', primary: '#EAB84E', primaryLight: '#F2D495', primaryLightest: '#FFFCEE', ink: '#171208' } } } };
    </script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700;900&family=Noto+Serif+Bengali:wght@400;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="./styles.css">
    <link rel="icon" href="./assets/logo.png">
    <style>
        .typing-dots {
            display: inline-flex;
            align-items: center;
        }
        .typing-dots span {
            height: 6px;
            width: 6px;
            background-color: #9CA3AF;
            border-radius: 50%;
            display: inline-block;
            margin-right: 3px;
            animation: typing 1.4s infinite ease-in-out;
        }
        .typing-dots span:nth-child(1) {
            animation-delay: -0.32s;
        }
        .typing-dots span:nth-child(2) {
            animation-delay: -0.16s;
        }
        @keyframes typing {
            0%, 80%, 100% {
                transform: scale(0);
                opacity: 0.5;
            }
            40% {
                transform: scale(1);
                opacity: 1;
            }
        }
        .message-wrapper {
            animation: slideIn 0.3s ease-out;
        }
        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        .chat-input-container {
            position: relative;
        }
        .chat-input-container:focus-within .input-border {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(234, 184, 78, 0.1);
        }
    </style>
</head>
<body class="bg-[color:var(--primaryLightest)]">
    <script>
        try { const u = JSON.parse(localStorage.getItem('bp_user')||'null'); if (!u || !u.uid) { location.href = './login.html'; } } catch { location.href = './login.html'; }
    </script>

    <header class="app-header">
        <div class="container header-inner">
            <div class="brand">
                <img src="./assets/logo.png" alt="BizPilot" class="logo" style="object-fit:contain;" onerror="this.src='data:image/svg+xml,%3Csvg xmlns=\'http://www.w3.org/2000/svg\' width=\'36\' height=\'36\' viewBox=\'0 0 36 36\'%3E%3Crect width=\'36\' height=\'36\' rx=\'10\' fill=\'%23EAB84E\'/%3E%3Ctext x=\'50%25\' y=\'55%25\' text-anchor=\'middle\' font-family=\'Arial\' font-size=\'14\'%3EBP%3C/text%3E%3C/svg%3E'">
                <div class="brand-text">
                    <strong>BizPilot</strong>
                    <span>AI Business Assistant</span>
                </div>
            </div>
            <nav class="main-nav items-center">
                <a href="./dashboard.html" class="nav-link">Dashboard</a>
                <a href="./wizard.html" class="nav-link">Wizard</a>
                <div class="relative ml-2">
                    <button id="header-profile-btn" class="w-9 h-9 rounded-full overflow-hidden border border-[color:var(--muted)] bg-[color:var(--primaryLightest)]" title="Profile" aria-label="Profile">
                        <img id="header-avatar" src="" alt="Profile" class="w-full h-full object-cover">
                    </button>
                </div>
            </nav>
        </div>
    </header>

    <main>
        <section class="view active" id="view-chat">
            <div class="container">
                <div class="max-w-3xl mx-auto bg-white border border-[color:var(--muted)] rounded-2xl shadow-sm overflow-hidden">
                    <div class="p-4 border-b border-[color:var(--muted)] flex items-center justify-between">
                        <div>
                            <h2 class="text-xl font-extrabold" id="chat-title">Chatbot</h2>
                            <p class="text-xs text-[color:var(--ink-60)]" id="chat-sub">Advice grounded in your selected idea.</p>
                        </div>
                        <a href="./dashboard.html" class="px-3 py-2 rounded-md border border-[color:var(--muted)] text-sm">Back</a>
                    </div>
                    <div id="chat-log" class="p-4 space-y-3 h-[60vh] overflow-y-auto bg-[color:var(--primaryLightest)]"></div>
                    <div class="p-4 border-t border-[color:var(--muted)] bg-white">
                        <form id="chat-form" class="chat-input-container">
                            <div class="flex gap-3 items-end">
                                <div class="flex-1">
                                    <input id="chat-input" type="text" class="w-full rounded-xl border border-[color:var(--muted)] px-4 py-3 text-sm input-border transition-all duration-200 focus:outline-none" placeholder="Ask about go-to-market, pricing, suppliers, current trends..." autocomplete="off" maxlength="1000">
                                    <div class="text-xs text-gray-400 mt-1">
                                        <span id="char-count">0</span>/1000 characters
                                    </div>
                                </div>
                                <button id="chat-send" type="submit" class="px-6 py-3 rounded-xl bg-[color:var(--primary)] text-white font-bold hover:bg-[color:var(--accent)] transition-colors duration-200 disabled:opacity-50 disabled:cursor-not-allowed" disabled>
                                    <span class="send-text">Send</span>
                                    <span class="send-loading hidden">Sending...</span>
                                </button>
                            </div>
                        </form>
                        <div class="text-xs text-[color:var(--ink-60)] mt-2 flex items-center justify-between">
                            <span id="seed-hint"></span>
                            <div class="flex items-center space-x-2">
                                <span class="text-xs text-gray-500">ðŸ’¡ Tip: Ask about current market trends for real-time insights</span>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </section>
    </main>

    <footer class="app-footer">
        <div class="container footer-inner">
            <span>Â© <span id="year"></span> BizPilot</span>
            <a href="#/privacy">Privacy</a>
            <a href="#/terms">Terms</a>
        </div>
    </footer>

    <script type="module" src="./db.js"></script>
    <script src="./services/aiService.js"></script>
    <script>
(function(){
    function getStore(){
        try { return JSON.parse(localStorage.getItem('bp_store_v1')||'{}'); } catch { return {}; }
    }
    function setYear(){ const y = document.getElementById('year'); if (y) y.textContent = String(new Date().getFullYear()); }
    function el(tag, cls, text){ const e = document.createElement(tag); if (cls) e.className = cls; if (text) e.textContent = text; return e; }
    const chatLog = document.getElementById('chat-log');
    const form = document.getElementById('chat-form');
    const input = document.getElementById('chat-input');
    const title = document.getElementById('chat-title');
    const sub = document.getElementById('chat-sub');
    const seedHint = document.getElementById('seed-hint');
    let history = [];
    let ideaId = null;
    let isProcessing = false;

    // Enhanced bubble creation with better formatting
    function appendBubble(role, text, metadata = null){
        const wrap = el('div', 'message-wrapper mb-4');
        const isUser = role === 'user';
        wrap.className = 'flex ' + (isUser ? 'justify-end' : 'justify-start') + ' mb-4';
        
        const bubble = el('div', 'max-w-[85%] px-4 py-3 rounded-2xl text-sm shadow-sm');
        if (isUser) {
            bubble.className += ' bg-[color:var(--primary)] text-white';
        } else {
            bubble.className += ' bg-white border border-[color:var(--muted)] text-gray-800';
        }
        
        // Format text with better structure
        const formattedText = formatResponseText(text);
        bubble.innerHTML = formattedText;
        
        // Add metadata if available
        if (metadata && !isUser) {
            const metaDiv = el('div', 'text-xs text-gray-500 mt-2 pt-2 border-t border-gray-200');
            if (metadata.timestamp) {
                metaDiv.textContent = new Date(metadata.timestamp).toLocaleTimeString();
            }
            if (metadata.sources && metadata.sources.length > 0) {
                const sourcesDiv = el('div', 'mt-1');
                sourcesDiv.innerHTML = '<strong>Sources:</strong> ' + metadata.sources.map(s => `<a href="${s.url}" target="_blank" class="text-blue-600 hover:underline">${s.title}</a>`).join(', ');
                metaDiv.appendChild(sourcesDiv);
            }
            bubble.appendChild(metaDiv);
        }
        
        wrap.appendChild(bubble);
        chatLog.appendChild(wrap);
        chatLog.scrollTop = chatLog.scrollHeight;
    }

    // Format response text with better structure
    function formatResponseText(text) {
        if (!text) return '';
        
        // Handle markdown-like formatting
        let formatted = text
            .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
            .replace(/\*(.*?)\*/g, '<em>$1</em>')
            .replace(/`(.*?)`/g, '<code class="bg-gray-100 px-1 py-0.5 rounded text-xs">$1</code>')
            .replace(/\n\n/g, '</p><p class="mt-2">')
            .replace(/\n/g, '<br>');
        
        // Wrap in paragraph if not already wrapped
        if (!formatted.includes('<p') && !formatted.includes('<div')) {
            formatted = '<p>' + formatted + '</p>';
        }
        
        return formatted;
    }

    // Add typing indicator
    function showTypingIndicator() {
        const wrap = el('div', 'flex justify-start mb-4');
        const bubble = el('div', 'max-w-[85%] px-4 py-3 rounded-2xl bg-white border border-[color:var(--muted)] shadow-sm');
        bubble.innerHTML = '<div class="flex items-center space-x-2"><div class="typing-dots"><span></span><span></span><span></span></div><span class="text-sm text-gray-500">AI is thinking...</span></div>';
        wrap.appendChild(bubble);
        chatLog.appendChild(wrap);
        chatLog.scrollTop = chatLog.scrollHeight;
        return wrap;
    }

    // Remove typing indicator
    function removeTypingIndicator(indicator) {
        if (indicator && indicator.parentNode) {
            indicator.parentNode.removeChild(indicator);
        }
    }

    function seedSystemMessage(ideaName, wizard){
        const take = (wizard && wizard.preferences && wizard.preferences.horizon) || '6m';
        const risk = (wizard && wizard.preferences && wizard.preferences.risk) || 'conservative';
        const loc = (wizard && wizard.location) || 'Unknown';
        const cat = (wizard && wizard.category) || '';
        seedHint.textContent = `Context: ${ideaName || 'Idea'} â€¢ ${loc} â€¢ ${cat} â€¢ Horizon ${take} â€¢ ${risk}`;
    }

    // removed explicit context injection to avoid the bot revealing background data

    // Web search functionality
    async function performWebSearch(query) {
        try {
            // Use a simple web search API (you can replace with your preferred search service)
            const searchUrl = `https://api.duckduckgo.com/?q=${encodeURIComponent(query)}&format=json&no_html=1&skip_disambig=1`;
            const response = await fetch(searchUrl);
            const data = await response.json();
            
            const results = [];
            if (data.RelatedTopics && data.RelatedTopics.length > 0) {
                data.RelatedTopics.slice(0, 3).forEach(topic => {
                    if (topic.Text && topic.FirstURL) {
                        results.push({
                            title: topic.Text.substring(0, 100) + '...',
                            url: topic.FirstURL,
                            snippet: topic.Text
                        });
                    }
                });
            }
            
            return results;
        } catch (error) {
            console.error('Web search error:', error);
            return [];
        }
    }

    // Enhanced chat processing with web search
    async function runChatTurn(userText){
        if (isProcessing) return;
        isProcessing = true;
        
        const st = getStore();
        const ideas = (st.ideas && st.ideas.items) || [];
        ideaId = (st.ideas && st.ideas.selectedId) || (ideas[0] && ideas[0].id);
        const sel = ideas.find(i => i.id === ideaId) || { name: 'Your Idea' };
        const wizard = st.wizard || {};
        const gps = (function(){ try { return JSON.parse(localStorage.getItem('bp_gps')||'null'); } catch { return null; } })();
        
        history.push({ role: 'user', content: userText });
        appendBubble('user', userText);
        
        // Show typing indicator
        const typingIndicator = showTypingIndicator();
        
        try {
            // Check if user is asking for current information that might need web search
            const needsWebSearch = /current|latest|recent|today|now|2024|2025|news|trends|market|prices|rates/i.test(userText);
            let webSearchResults = [];
            
            if (needsWebSearch) {
                // Perform web search for current information
                webSearchResults = await performWebSearch(userText);
            }
            
            // Try to augment wizard with persisted assets for richer context
            const user = (st.profile && st.profile.user) || null;
            let wizForChat = wizard;
            if (user && user.uid && window.DB && window.DB.readIdea && ideaId) {
                try {
                    const saved = await window.DB.readIdea(user.uid, ideaId);
                    if (saved && (saved.photos || saved.pdf)) {
                        wizForChat = Object.assign({}, wizard);
                        // Convert remote URLs into inline base64 for Gemini context if CORS allows
                        async function toDataUrl(url){
                            try { const r = await fetch(url, { mode: 'cors' }); const b = await r.blob(); return await new Promise((res, rej) => { const fr = new FileReader(); fr.onload = () => res(fr.result); fr.onerror = rej; fr.readAsDataURL(b); }); } catch { return null; }
                        }
                        const images = [];
                        if (Array.isArray(saved.photos)) {
                            for (const p of saved.photos) {
                                const dataUrl = await toDataUrl(p.url);
                                if (dataUrl) images.push({ name: p.name || 'photo', data: String(dataUrl) });
                            }
                        }
                        if (images.length) wizForChat.images = images;
                        if (saved.pdf && saved.pdf.url) {
                            const dataUrl = await toDataUrl(saved.pdf.url);
                            if (dataUrl) wizForChat.pdf = { name: saved.pdf.name || 'document.pdf', data: String(dataUrl) };
                        }
                    }
                } catch {}
            }
            
            // Pass any existing analysis for stronger context
            const analysis = (st.analysisByIdea && st.analysisByIdea[ideaId]) || null;
            
            // Create enhanced context with web search results
            const enhancedContext = {
                ideaName: sel.name,
                wizard: wizForChat,
                gps,
                history,
                analysis,
                webSearchResults
            };
            
            const res = await window.AIService.chatWithIdeaEnhanced(enhancedContext);
            
            // Remove typing indicator
            removeTypingIndicator(typingIndicator);
            
            // Add response with metadata
            const metadata = {
                timestamp: new Date().toISOString(),
                sources: webSearchResults
            };
            
            appendBubble('assistant', res.reply || 'I apologize, but I encountered an issue processing your request.', metadata);
            history.push({ role: 'assistant', content: res.reply || '' });
            persistChat(ideaId, history);
            
        } catch (error) {
            console.error('Chat error:', error);
            removeTypingIndicator(typingIndicator);
            appendBubble('assistant', 'I apologize, but I encountered an issue processing your request. Please try again.');
        } finally {
            isProcessing = false;
        }
    }

    // Persist chat per-idea with localStorage fallback and Firestore if available
    function persistChat(id, hist){
        try { localStorage.setItem(`bp_chat_${id}`, JSON.stringify(hist.slice(-50))); } catch {}
        try {
            const st = getStore();
            const user = st.profile && st.profile.user;
            if (user && user.uid && window.DB && window.DB.writeIdeaChat) {
                window.DB.writeIdeaChat(user.uid, id, hist.slice(-100));
            }
        } catch {}
    }

    function loadChat(id){
        try {
            const raw = localStorage.getItem(`bp_chat_${id}`);
            if (!raw) return [];
            const arr = JSON.parse(raw);
            return Array.isArray(arr) ? arr : [];
        } catch { return []; }
    }

    window.addEventListener('load', () => {
        setYear();
        const st = getStore();
        const ideas = (st.ideas && st.ideas.items) || [];
        const selId = (st.ideas && st.ideas.selectedId) || (ideas[0] && ideas[0].id);
        const sel = ideas.find(i => i.id === selId) || { name: 'Your Idea' };
        title.textContent = `AI Chatbot â€” ${sel.name || 'Idea'}`;
        sub.textContent = 'Advice grounded in your selected idea.';
        seedSystemMessage(sel.name, st.wizard || {});
        // Load previous chat for this idea
        if (selId) {
            ideaId = selId;
            history = loadChat(selId);
            history.forEach(m => appendBubble(m.role, m.content));
        }

        // Character counter
        const charCount = document.getElementById('char-count');
        const sendBtn = document.getElementById('chat-send');
        const sendText = document.querySelector('.send-text');
        const sendLoading = document.querySelector('.send-loading');
        
        if (input && charCount) {
            input.addEventListener('input', () => {
                const count = input.value.length;
                charCount.textContent = count;
                
                // Enable/disable send button
                if (count > 0 && count <= 1000 && !isProcessing) {
                    sendBtn.disabled = false;
                } else {
                    sendBtn.disabled = true;
                }
            });
        }

        if (form && input) {
            form.addEventListener('submit', async (e) => {
                e.preventDefault();
                const text = (input.value || '').trim();
                if (!text || isProcessing) return;
                
                // Update UI to show processing state
                sendBtn.disabled = true;
                sendText.classList.add('hidden');
                sendLoading.classList.remove('hidden');
                input.disabled = true;
                
                // Clear input
                input.value = '';
                charCount.textContent = '0';
                
                try {
                    await runChatTurn(text);
                } finally {
                    // Reset UI state
                    sendBtn.disabled = false;
                    sendText.classList.remove('hidden');
                    sendLoading.classList.add('hidden');
                    input.disabled = false;
                    input.focus();
                }
            });
        }

        // Handle Enter key for better UX
        if (input) {
            input.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    if (!sendBtn.disabled) {
                        form.dispatchEvent(new Event('submit'));
                    }
                }
            });
        }
    });
})();
    </script>
</body>
</html>


